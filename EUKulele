## Draft Snakefile Sketch
import os
import pandas as pd

configfile: "config.yaml"  

CONSENSUS_CUTOFF = config['consensus_cutoff']
REFERENCE_DIR = config['reference']
OUTPUT_DIR = config['output']
DATABASE_DIR = os.path.join(OUTPUT_DIR, "database")
SAMPLE_DIR = config['samples']
REF_FASTA = config['ref_fasta']
TAX_TAB = config['ref_tax']
PROT_TAB = config['ref_prot']
ALIGNMENT_CHOICE = config['alignment-choice']
EXTENSION = "txt"
DBEXTENSION = ""
if ALIGNMENT_CHOICE == "diamond":
    EXTENSION = "out"
    DBEXTENSION = ".dmnd"

def get_alignment(ALIGNMENT_CHOICE, mets_or_mags, filename):
    if mets_or_mags == "METs":
        if ALIGNMENT_CHOICE == "diamond":
            return os.path.join(OUTPUT_DIR, "METs", "diamond", filename + ".diamond.out")
        elif ALIGNMENT_CHOICE == "blast":
            return os.path.join(OUTPUT_DIR, "METs", "blast", filename + ".blast.txt")
    elif mets_or_mags == "MAGs":
        if ALIGNMENT_CHOICE == "diamond":
            return os.path.join(OUTPUT_DIR, "MAGs", "diamond", filename + ".diamond.out")
        elif ALIGNMENT_CHOICE == "blast":
            return os.path.join(OUTPUT_DIR, "MAGs", "blast", filename + ".blast.txt")

METEXT = "fa"    
IFPARALLEL = "parallel"
MTS, = glob_wildcards(os.path.join(SAMPLE_DIR, "METs", "{T}." + METEXT))
MAG, = glob_wildcards(os.path.join(SAMPLE_DIR, "MAGs", "{G}.faa"))

rule all: 
    input:
        ref_db = expand(os.path.join(REFERENCE_DIR, "{aligner}", REF_FASTA.strip('.fa') + "{extension}"), aligner = ALIGNMENT_CHOICE, extension = DBEXTENSION),
        mt_aln = expand(os.path.join(OUTPUT_DIR, "METs", "{aligner}", "{T}.{aligner}.{extension}"), T = MTS, aligner = ALIGNMENT_CHOICE, extension = EXTENSION), 
        mt_tax = expand(os.path.join(OUTPUT_DIR, "METs", "{T}-estimated-taxonomy-{ifparallel}.out"), T = MTS, ifparallel = IFPARALLEL), 
        mag_aln = expand(os.path.join(OUTPUT_DIR, "MAGs", "{aligner}", "{G}.{aligner}.{extension}"), G = MAG, aligner = ALIGNMENT_CHOICE, extension = EXTENSION), 
        mag_tax = expand(os.path.join(OUTPUT_DIR, "MAGs", "{G}-estimated-taxonomy.out"), G = MAG), 
        mag_assignment = expand(os.path.join(OUTPUT_DIR, "MAGs", "{G}-max-level.csv"), G = MAG)

rule setup_reference:
    input: os.path.join(REFERENCE_DIR, REF_FASTA)
    output: os.path.join(DATABASE_DIR, "diamond", REF_FASTA.strip('.fa') + ".dmnd")
    params:
        diamondfile = os.path.join(REFERENCE_DIR, REF_FASTA.strip('.fa') + '.dmnd'),
        db = os.path.join(DATABASE_DIR, "diamond", REF_FASTA.strip('.fa'))
    conda:
         "envs/diamond.yaml"
    shell:
        """
        diamond makedb --in {input} --db {params.db}
        """
        
rule setup_reference_blast:
    input: os.path.join(REFERENCE_DIR, REF_FASTA)
    output: directory(os.path.join(DATABASE_DIR, "blast", REF_FASTA.strip('.fa')))
    params:
        db = os.path.join(DATABASE_DIR, "blast", REF_FASTA.strip('.fa'), "database"),
        db_name = "MMETSPDatabase",
        db_type = "prot",
        blast_version = 5
    conda:
         "envs/blast.yaml"
    shell:
        """
        makeblastdb -in {input} -parse_seqids -blastdb_version {params.blast_version} -title {params.db_name} -dbtype {params.db_type} -out {params.db}
        """

#rule check_if_protein:
    ## uses GeneMark-ES to predict protein coding regions
    ## Or a metaT protein prediction (???)
    ## Also allow users to pass proteins directly.


rule align_METs_against_db:
  ## runs alignment against reference DB and generates .aln files for each contig in each samples
    input:
        dmnd = os.path.join(DATABASE_DIR, "diamond", REF_FASTA.strip('.fa')+'.dmnd'), 
        fasta = os.path.join(SAMPLE_DIR, "METs", "{T}." + METEXT) 
    output:
        os.path.join(OUTPUT_DIR, "METs", "diamond", "{T}.diamond.out")
    params:
        other = "--outfmt 6 -k 100 -e 1e-5",
        outfmt = 6,
        k = 100,
        e = 1e-5
    conda:
        "envs/diamond.yaml"
    shell:
        """
        diamond blastx --db {input.dmnd} -q {input.fasta} -o {output} --outfmt {params.outfmt} -k {params.k} -e {params.e}
        """

rule align_METs_against_db_blast:
  ## runs alignment against reference DB and generates .aln files for each contig in each samples
    input:
        blast = os.path.join(DATABASE_DIR, "blast", REF_FASTA.strip('.fa')), 
        fasta = os.path.join(SAMPLE_DIR, "METs", "{T}." + METEXT) 
    output:
        os.path.join(OUTPUT_DIR, "METs", "blast", "{T}.blast.txt")
    params:
        db = os.path.join(DATABASE_DIR, "blast", REF_FASTA.strip('.fa'), "database"),
        outfmt = 6, # tabular output format
        e = 1e-5
    conda:
        "envs/blast.yaml"
    shell:
        """
        export BLASTDB={params.db}
        blastx -query {input.fasta} -db {params.db} -out {output} -outfmt {params.outfmt} -evalue {params.e}
        """

rule align_MAGs_against_db:
  ## runs alignment against reference DB and generates .aln files for each contig in each samples
    input:
        dmnd = os.path.join(DATABASE_DIR, "diamond", REF_FASTA.strip('.fa')+'.dmnd'), 
        fasta = os.path.join(SAMPLE_DIR, "MAGs", "{G}.faa")
    output:
        os.path.join(OUTPUT_DIR, "MAGs", "diamond", "{G}.diamond.out")
    params:
        other ="--outfmt 6 -k 100 -e 1e-5",
        outfmt = 6,
        k = 100,
        e = 1e-5
    conda:
        "envs/diamond.yaml"
    shell:
        """
        diamond blastp --db {input.dmnd} -q {input.fasta} -o {output} --outfmt {params.outfmt} -k {params.k} -e {params.e}
        """ 
        
rule align_MAGs_against_db_blast:
  ## runs alignment against reference DB and generates .aln files for each contig in each samples
    input:
        blast = os.path.join(DATABASE_DIR, "blast", REF_FASTA.strip('.fa')), 
        fasta = os.path.join(SAMPLE_DIR, "MAGs", "{G}.faa") 
    output:
        os.path.join(OUTPUT_DIR, "MAGs", "blast", "{G}.blast.txt")
    params:
        db = os.path.join(DATABASE_DIR, "blast", REF_FASTA.strip('.fa'), "database"),
        outfmt = 6, # tabular output format
        e = 1e-5
    conda:
        "envs/blast.yaml"
    shell:
        """
        export BLASTDB={params.db}
        blastp -query {input.fasta} -db {params.db} -out {output} -outfmt {params.outfmt} -evalue {params.e}
        """ 

#rule estimate_taxonomy_MAG:
  ## based on hits within a MAG file -- estimates the LCA for each MAG based on reference DB
  ## include an additional file that estimates the contamination (?) or shows next highest hits with the MAG
  ## provide basic statistics on the hits
   
rule estimate_taxonomy_METs:
    input: 
        file = lambda filename: get_alignment(ALIGNMENT_CHOICE, mets_or_mags = "METs", filename = filename.T) 
    output: 
        outfile = os.path.join(OUTPUT_DIR, "METs", "{T}-estimated-taxonomy-{parallel}.out")
    params:
        consensus = CONSENSUS_CUTOFF,
        method = "{parallel}",
        tax_file = os.path.join(config['reference'], config['ref_tax']),
        outfile_series = os.path.join(OUTPUT_DIR, "METs", "{T}-estimated-taxonomy.out"),
        prot_json = os.path.join(config['reference'], config['ref_prot']),
        cutoff = config['cutoff']
    conda: 
        'envs/estimate.yaml'
    shell:
        """
        echo {input.file}
        time python scripts/tax-placement.py --tax_file {params.tax_file} --cutoff_file {params.cutoff} --prot_map_file {params.prot_json} --diamond_file {input.file} --outfile {output.outfile} --method {params.method} --consensus_cutoff {params.consensus}
        """

rule estimate_taxonomy_MAG_proteins:
    input: 
        file = lambda filename: get_alignment(ALIGNMENT_CHOICE, mets_or_mags = "MAGs", filename = filename.G) 
    output: os.path.join(OUTPUT_DIR, "MAGs", "{G}-estimated-taxonomy.out")
    params:
        consensus = CONSENSUS_CUTOFF,
        tax_file = os.path.join(config['reference'], config['ref_tax']),
        prot_json = os.path.join(config['reference'], config['ref_prot']),
        cutoff = config['cutoff']
    conda: 
        'envs/estimate.yaml'
    shell:
        """
        python scripts/tax-placement.py --tax_file {params.tax_file} --cutoff_file {params.cutoff} --prot_map_file {params.prot_json} --diamond_file {input.file} --outfile {output} --consensus_cutoff {params.consensus}
        """

rule assign_MAG_taxonomy:
    input: os.path.join(OUTPUT_DIR, "MAGs", "{G}-estimated-taxonomy.out")
    output: os.path.join(OUTPUT_DIR, "MAGs", "{G}-max-level.csv")
    params: 
        prefix = '{G}',
        levels_directory = os.path.join(OUTPUT_DIR, "MAGs", "levels"),
        max_dir = os.path.join(OUTPUT_DIR, "MAGs")
    conda: 
        'envs/estimate.yaml'
    shell:
        """
        python scripts/mag-stats.py --estimated-taxonomy-file {input} --out-prefix {params.prefix} --outdir {params.levels_directory} --max-out-dir {params.max_dir}
        """
